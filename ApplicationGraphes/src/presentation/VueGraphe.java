/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package presentation;

import coucheApplicative.Modele;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import javax.swing.JPanel;
import metier.IConstantes;
import static metier.IConstantes.CHANGER_NOM;
import static metier.IConstantes.GENERER;

/**
 *
 * @author Hans
 */
public class VueGraphe extends JPanel implements IConstantes, Observer {

//  le modele
    private Modele mdl;
//  le controleur
    private Controleur ctrl;
//  la vueBas
    private VueBas vueBas;
//  la vueCentre
    private VueGauche vueGauche;
//  la vueGauche
    private VueCentre vueCentre;
// Map de iconesSommets avec pour clé les noms des sommets
    private Map<String, IconeSommet> lesIconesSommets;
// Map de iconeArrete avec pour clé la concatéantion du nom des 2 sommets de chaque extrémité
    private Map<String, IconeArrete> lesIconesArretes;

    /**
     * Constructeur
     */
    public VueGraphe() {
        lesIconesSommets = new HashMap();
        lesIconesArretes = new HashMap();
        setLayout(new BorderLayout());
        mdl = new Modele();
        mdl.addObserver(this);
        ctrl = new Controleur(mdl);
        add(panneauCentre(), BorderLayout.CENTER);
        add(panneauGauche(), BorderLayout.WEST);
        add(panneauBas(), BorderLayout.SOUTH);

        this.setVisible(true);
    }

    /**
     * Place des sommets à des positions randoms
     */
    private void randomPosition() {
        double temp;
        for (IconeSommet ico : lesIconesSommets.values()) {
            IconeSommet som = ico;
            temp = (Math.random());
            som.getPos()[0] = temp;
            temp = (Math.random());
            som.getPos()[1] = temp;

        }

    }



    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(0, 102, 102));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    /**
     * Calcul position
     *
     * @param objetObserve l'objet observé
     * @param uneInformation l'information
     */
    public void update(Observable objetObserve, Object uneInformation) {
        if (objetObserve instanceof Modele) {
            String tabInfos[] = uneInformation.toString().split(SEPARATEUR);

            if (tabInfos[0].equals(MODE_SOMMET)) {
                modeSommet();
            } else if (tabInfos[0].equals(MODE_ARRETE)) {
                modeArrete();
            } else if (tabInfos[0].equals(MODE_FLECHE)) {
                modeFleche();
            } else if (tabInfos[0].equals(AJOUTER_SOMMET)) {
                double x = Double.parseDouble(tabInfos[1]);
                double y = Double.parseDouble(tabInfos[2]);
                String nomSommet = tabInfos[3];
                
                vueCentre.ajouterSommet(nomSommet, x, y, ctrl);


            } else if (tabInfos[0].equals(GENERER)) {
                genererGraphe();

            } else if (tabInfos[0].equals(CHANGER_NOM)) {
                IconeSommet aux = lesIconesSommets.get(tabInfos[1]);
                aux.updateName(tabInfos[2]);
                lesIconesSommets.remove(tabInfos[1]);
                lesIconesSommets.put(tabInfos[2], aux);
                

            }
            else if (tabInfos[0].equals(AFFICHE_TEXTF)) {
                IconeSommet aux = lesIconesSommets.get(tabInfos[1]);
                aux.modeTextField();
            }
        }
    }

    /**
     * génère un graphe
     */
    public void genererGraphe() {
        //generationDesIcones();
        randomPosition();
        // vueCentre.repaint();
    }

    /**
     * Crée le panneau du bas
     */
    private Component panneauBas() {
        vueBas = new VueBas(ctrl);
        return vueBas;
    }

    private Component panneauGauche() {
        vueGauche = new VueGauche(ctrl);
        return vueGauche;
    }

    /**
     * Crée le panneau du centre
     */
    private Component panneauCentre() {
        vueCentre = new VueCentre(ctrl, lesIconesSommets, lesIconesArretes);
        return vueCentre;
    }

    /**
     * Permet de passer en mode sommet
     */
    private void modeSommet() {

        Toolkit toolkit = Toolkit.getDefaultToolkit();
        Dimension dim = toolkit.getBestCursorSize(48, 48);
        BufferedImage newImage = new BufferedImage(48, 48, BufferedImage.TYPE_INT_ARGB);

        Shape circle = new Ellipse2D.Double(0, 0, dim.width - 1, dim.height - 1);

        int centerX = (dim.width - 30) / 2;
        int centerY = (dim.height - 30) / 2;

        Graphics2D g = newImage.createGraphics();

        g.setColor(Color.ORANGE);
        g.fill(circle);

        Cursor customCursor = toolkit.createCustomCursor(newImage, new Point(centerX, centerY), "Cursor");
        this.setCursor(customCursor);

    }

    /**
     * Permet de passer en mode arrete
     */
    private void modeArrete() {
        Cursor curseur = new Cursor(Cursor.CROSSHAIR_CURSOR);
        this.setCursor(curseur);
    }

    /**
     * Permet de passer en mode par défault
     */
    private void modeFleche() {
        Cursor curseur = new Cursor(Cursor.DEFAULT_CURSOR);
        this.setCursor(curseur);
    }
}
